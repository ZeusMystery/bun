# How bun works

Bun is roughly four large projects in one.

- Bun.js
- JavaScript & TypeScript parser
- Bundler
- npm package manager

### Why is bun fast?

There are a lot of reasons for this. Mostly, bun tries really hard to minimize memory usage/allocations and bun leverages lots of platform-specific syscalls to make stuff happen faster.

## Bun.js

Bun uses JavaScriptCore instead of the more commonly-embedded V8.

#### Why JavaScriptCore instead of V8?

JavaScriptCore tends to have significantly better startup performance, faster native bindings, alongside lower memory usage and marginally better runtime performance at things like math.

The downside is worse async/promise performance and lower quality Windows support.

It's also much harder to embed because there are no docs and it is not designed for embedding outside of WebKit/Safari. Figuring out how to embed JavaScriptCore in bun was about a month of work.

#### Zig <> JavaScriptCore interop

Zig has fantastic C support and JavaScriptCore _does_ have a C API. It's not as fast as JavaScriptCore's internal C++ API though.

Bun tries to use the C++ API as much as possible but there are no automated bindings yet.

Currently, Bun has a giant [./headers.h](./src/javascript/jsc/bindings/headers.h) file which is generated by reading the types exported in [./exports.zig](./src/javascript/jsc/bindings/exports.zig). `headers.h` is run through `zig translate-c` to generate [./headers.zig](./src/javascript/jsc/bindings/headers.zig). This turns any C ABI differences between Zig code and C++ code into a compile error.

From there, [`bindings.cpp`](./src/javascript/jsc/bindings/bindings.cpp) represents most of the C++ bindings. Not all of these functions are currently in use – I was learning C++ as I wrote it.

The sizes and alignment of C++ types are [synced](./src/javascript/jsc/bindings/sizes.zig) from C++ -> Zig, but Bun generally treats C++ types as opaque pointers and accesses via function calls because JavaScriptCore uses lots of runtime-typing and using C++ this way means RAII doesn't happen.

For zig-only types exposed to JavaScript, Bun uses JavaScriptCore's C API. [`JSC.NewClass`](https://github.com/Jarred-Sumner/bun/blob/89ca887ea0c0c673f1c1c22cb5913f09435feeb6/src/javascript/jsc/base.zig#L878) defines a JavaScript class. After defining the class, if the type has instance-specific data (like `Response`), the type must be added to this [`TaggedPointerUnion`](https://github.com/Jarred-Sumner/bun/blob/89ca887ea0c0c673f1c1c22cb5913f09435feeb6/src/javascript/jsc/base.zig#L2572). Every pointer from Zig to JavaScript is tagged with a type and that tag is checked for validity. This is a security measure that also helps with debugging.

Eventually, Bun should move to using JavaScriptCore's C++ API with bindings generated similarly to Web IDL (except from Zig potentially).

##### Strings between Zig <> JSC

JavaScriptCore has many ways to represent a string, mostly contained in `WTF::String`. Strings can be either 16 bit or 8 bit. 16 bit strings are UTF-16, 8 bit strings are latin1. UTF-8 strings are not supported. `WTF::String` contains a `WTF::StringImpl`, which is a subclass that supports strings with memory managed externally, statically allocated strings (AtomicString), and strings that are garbage collected. This is a reference-counted type (like many in JSC).

Most of the time, strings from Zig -> JSC are cloned, both the `WTF::StringImpl` and the underlying bytes. This has a performance cost, but makes the lifetime of strings much simpler.

However, strings from JSC -> Zig are usually not cloned unless it's UTF-16 and conversion from UTF-16 to UTF-8 is necessary. In many cases, reading strings in bun.js is faster than typed arrays.

### Bun's JavaScript parser is deeply integrated into the runtime

When you import a file in Bun.js, Bun's node_modules resolver runs and the JavaScript/TypeScript parser always runs when fetching the code, even if technically the file might not need to be transpiled.

This is for ecosystem compatibility. This enables many npm packages to "just work", despite not being the same runtime as Node.js and it enables behavior like tsconfig.json `"paths"` to work with zero additional configuration.

### Embedding WebCore

[WebCore](https://github.com/WebKit/webkit/tree/main/Source/WebCore) is the web browser part of WebKit. Bun embeds parts of WebCore and exposes them to JavaScript – must of these classes are in the [`webcore`](./src/javascript/jsc/bindings/webcore/) folder.

Currently, these are manually copy-pasted and slightly edited (mostly to comment out code not relevant to bun). It is not simple. Longer-term, it would be better to statically link WebCore or consider turning parts of this usage into a WebKit port (similar to how PlayStation embeds WebKit).

## JavaScript & TypeScript Parser

The design was initially modeled after [esbuild](https://github.com/evanw/esbuild/blob/main/docs/architecture.md) and many of esbuild's comments are in bun's codebase (@evanw writes fantastic documentation). [The AST](./src/js_ast.zig) data layout is still similar to esbuild, however finer-grain control over memory management with Zig led to better performance

## Two passes

1. Parsing
2. Visiting

#### Hot Module Reloading

#### Memory management

Statements and expressions are allocated in blocks of continguous memory.

```zig
const Block = struct {
    used: SizeType = 0,
    items: [count]UnionValueType align(MaxAlign) = undefined,
};
```

At the time of writing, several AST nodes are stack allocated.
